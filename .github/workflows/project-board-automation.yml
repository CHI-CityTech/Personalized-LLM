name: Project Board Automation
on:
  issues:
    types: [opened, closed, reopened]
  pull_request:
    types: [opened, closed, reopened, ready_for_review, converted_to_draft]

jobs:
  update-project-board:
    runs-on: ubuntu-latest
    steps:
      - name: Move items in Projects V2 based on issue/PR state
        uses: actions/github-script@v7
        with:
          script: |
            // Projects V2 migration: use GraphQL to find a repository project, add items and update a single-select field to represent status.
            // Assumptions:
            // - The target Project V2 exists and has a single-select field with options matching: backlog, in progress, in review, done (case-insensitive).
            // - Projects V2 items for this repository are small enough to search within the first 100 items. For larger projects, this should be paginated.

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const targetProjectTitle = 'Research Progress';

            // Helper: fetch repository projectsV2, fields and first page of items
            const repoQuery = `
              query($owner:String!, $repo:String!) {
                repository(owner:$owner, name:$repo) {
                  projectsV2(first:20) {
                    nodes {
                      id
                      title
                      fields(first:50) {
                        nodes {
                          id
                          name
                          __typename
                          ... on ProjectV2SingleSelectField {
                            options { id name }
                          }
                        }
                      }
                      items(first:100) {
                        nodes {
                          id
                          content {
                            __typename
                            ... on Issue { number }
                            ... on PullRequest { number }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            let repoRes;
            try {
              repoRes = await github.graphql(repoQuery, { owner, repo });
            } catch (err) {
              console.log('GraphQL query for projectsV2 failed, skipping project automation.');
              console.log(err && err.message ? err.message : String(err));
              return;
            }

            if (!repoRes || !repoRes.repository || !repoRes.repository.projectsV2) {
              console.log('No projectsV2 found for repository.');
              return;
            }

            const projects = repoRes.repository.projectsV2.nodes;
            if (!projects || projects.length === 0) {
              console.log('No Projects V2 nodes returned.');
              return;
            }

            const project = projects.find(p => p.title === targetProjectTitle) || projects[0];
            console.log('Using project:', project.title);

            // Find a single-select field that has options matching our expected columns
            function findStatusField(project) {
              if (!project.fields || !project.fields.nodes) return null;
              const fields = project.fields.nodes;
              // look for single-select fields (they have __typename 'ProjectV2SingleSelectField')
              for (const f of fields) {
                if (f.__typename === 'ProjectV2SingleSelectField' && f.options && f.options.length > 0) {
                  // check if options include any of our known statuses
                  const optionNames = f.options.map(o => o.name.toLowerCase());
                  const wanted = ['backlog','in progress','in review','done'];
                  if (wanted.some(w => optionNames.includes(w))) return f;
                }
              }
              return null;
            }

            const statusField = findStatusField(project);
            if (!statusField) {
              console.log('Could not find a single-select status field on the project. Skipping automation.');
              return;
            }

            // Helper to find option id by name (case-insensitive)
            function findOptionId(field, name) {
              if (!field.options) return null;
              const opt = field.options.find(o => o.name.toLowerCase() === name.toLowerCase());
              return opt ? opt.id : null;
            }

            // Helper to find an existing project item for an issue/PR by number
            function findItemForNumber(project, typename, number) {
              if (!project.items || !project.items.nodes) return null;
              for (const node of project.items.nodes) {
                if (node.content && node.content.__typename === typename && node.content.number === number) return node.id;
              }
              return null;
            }

            // Determine desired status name by event/action
            let desiredStatus = null;

            if (context.eventName === 'issues') {
              const issue = context.payload.issue;
              if (!issue) return;
              if (context.payload.action === 'opened') {
                desiredStatus = 'backlog';
              } else if (context.payload.action === 'closed') {
                desiredStatus = 'done';
              } else if (context.payload.action === 'reopened') {
                desiredStatus = 'backlog';
              }

              if (!desiredStatus) return;

              // Get Node ID for the issue
              const contentNodeId = issue.node_id || (issue.id ? `Issue:${issue.id}` : null);
              // Prefer payload.node_id; fall back to REST lookup for node_id if necessary
              let nodeId = contentNodeId;
              if (!nodeId) {
                try {
                  const got = await github.rest.issues.get({ owner, repo, issue_number: issue.number });
                  nodeId = got.data && got.data.node_id;
                } catch (e) {
                  console.log('Could not determine issue node_id; skipping.');
                  return;
                }
              }

              // Ensure there's a project item for this issue
              let itemId = findItemForNumber(project, 'Issue', issue.number);
              if (!itemId) {
                try {
                  const addMut = `mutation($projectId:ID!, $contentId:ID!) { addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) { item { id } } }`;
                  const addRes = await github.graphql(addMut, { projectId: project.id, contentId: nodeId });
                  itemId = addRes && addRes.addProjectV2ItemById && addRes.addProjectV2ItemById.item && addRes.addProjectV2ItemById.item.id;
                  console.log('Added project item for issue:', itemId);
                } catch (e) {
                  console.log('Failed to add issue to Project V2:', e && e.message ? e.message : String(e));
                  return;
                }
              }

              // Update the single-select status field
              const optionId = findOptionId(statusField, desiredStatus);
              if (!optionId) {
                console.log(`Status option '${desiredStatus}' not found on project field; skipping update.`);
                return;
              }

              const updateMut = `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $value:ProjectV2ItemFieldValueInput!) { updateProjectV2ItemFieldValue(input:{projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value}) { projectV2Item { id } } }`;
              try {
                await github.graphql(updateMut, { projectId: project.id, itemId, fieldId: statusField.id, value: { singleSelectOptionId: optionId } });
                console.log('Updated issue item status to', desiredStatus);
              } catch (e) {
                console.log('Failed to update project item field value:', e && e.message ? e.message : String(e));
              }
              return;
            }

            if (context.eventName === 'pull_request') {
              const pr = context.payload.pull_request;
              if (!pr) return;

              if (context.payload.action === 'opened') {
                desiredStatus = 'in progress';
              } else if (context.payload.action === 'ready_for_review') {
                desiredStatus = 'in review';
              } else if (context.payload.action === 'converted_to_draft') {
                desiredStatus = 'in progress';
              } else if (context.payload.action === 'closed') {
                desiredStatus = pr.merged ? 'done' : 'backlog';
              }

              if (!desiredStatus) return;

              const contentNodeId = pr.node_id || (pr.id ? `PullRequest:${pr.id}` : null);
              let nodeId = contentNodeId;
              if (!nodeId) {
                try {
                  const got = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
                  nodeId = got.data && got.data.node_id;
                } catch (e) {
                  console.log('Could not determine PR node_id; skipping.');
                  return;
                }
              }

              // Find or add project item for PR
              let itemId = findItemForNumber(project, 'PullRequest', pr.number);
              if (!itemId) {
                try {
                  const addMut = `mutation($projectId:ID!, $contentId:ID!) { addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) { item { id } } }`;
                  const addRes = await github.graphql(addMut, { projectId: project.id, contentId: nodeId });
                  itemId = addRes && addRes.addProjectV2ItemById && addRes.addProjectV2ItemById.item && addRes.addProjectV2ItemById.item.id;
                  console.log('Added project item for PR:', itemId);
                } catch (e) {
                  console.log('Failed to add PR to Project V2:', e && e.message ? e.message : String(e));
                  return;
                }
              }

              // Update status
              const optionId = findOptionId(statusField, desiredStatus);
              if (!optionId) {
                console.log(`Status option '${desiredStatus}' not found on project field; skipping update.`);
                return;
              }

              const updateMut = `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $value:ProjectV2ItemFieldValueInput!) { updateProjectV2ItemFieldValue(input:{projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:$value}) { projectV2Item { id } } }`;
              try {
                await github.graphql(updateMut, { projectId: project.id, itemId, fieldId: statusField.id, value: { singleSelectOptionId: optionId } });
                console.log('Updated PR item status to', desiredStatus);
              } catch (e) {
                console.log('Failed to update project item field value:', e && e.message ? e.message : String(e));
              }
              return;
            }